/*
 * Analyzer and HUB API
 * The definition of the software interface between analyzers and the HUB.  The interface will be implemented as a RESTful interface with all server endpoints hosted on the Analyzer.  The following requirements will be met by all interfaces:  1. All data passed back from server shall be in JSON format. 2. All query parameters and JSON data properties shall be named using snake case and be all lower case. 4. All data types that describe a measurement value shall end with an underscore followed by the unit of that physical value.  i.e. motor_current_ma.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.math.BigDecimal;

/**
 * This object will contain results of the most recent measurement
 */
@ApiModel(description = "This object will contain results of the most recent measurement")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2021-09-01T10:02:09.757-04:00[America/Nassau]")
public class MeasurementResult {
  public static final String SERIALIZED_NAME_CONSUMABLE_NAME = "consumable_name";
  @SerializedName(SERIALIZED_NAME_CONSUMABLE_NAME)
  private String consumableName;

  public static final String SERIALIZED_NAME_START_DATE_AND_TIME = "start_date_and_time";
  @SerializedName(SERIALIZED_NAME_START_DATE_AND_TIME)
  private String startDateAndTime;

  public static final String SERIALIZED_NAME_END_DATE_AND_TIME = "end_date_and_time";
  @SerializedName(SERIALIZED_NAME_END_DATE_AND_TIME)
  private String endDateAndTime;

  public static final String SERIALIZED_NAME_DURATION_SEC = "duration_sec";
  @SerializedName(SERIALIZED_NAME_DURATION_SEC)
  private BigDecimal durationSec;

  /**
   * The overall result of the measurement
   */
  @JsonAdapter(ResultEnum.Adapter.class)
  public enum ResultEnum {
    FAILED("Failed"),
    
    CANCELLED("Cancelled"),
    
    COMPLETED("Completed");

    private String value;

    ResultEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ResultEnum fromValue(String value) {
      for (ResultEnum b : ResultEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ResultEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ResultEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ResultEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ResultEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_RESULT = "result";
  @SerializedName(SERIALIZED_NAME_RESULT)
  private ResultEnum result;

  public static final String SERIALIZED_NAME_TEST_RESULTS = "test_results";
  @SerializedName(SERIALIZED_NAME_TEST_RESULTS)
  private Object testResults;


  public MeasurementResult consumableName(String consumableName) {
    
    this.consumableName = consumableName;
    return this;
  }

   /**
   * A descriptive name of the consumable that can be used to uniquely identify it
   * @return consumableName
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A descriptive name of the consumable that can be used to uniquely identify it")

  public String getConsumableName() {
    return consumableName;
  }


  public void setConsumableName(String consumableName) {
    this.consumableName = consumableName;
  }


  public MeasurementResult startDateAndTime(String startDateAndTime) {
    
    this.startDateAndTime = startDateAndTime;
    return this;
  }

   /**
   * The local date and time the measurement was started in format MM-DD-YYYY HH:MM:SS
   * @return startDateAndTime
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "05-05-2021 22:07:04", value = "The local date and time the measurement was started in format MM-DD-YYYY HH:MM:SS")

  public String getStartDateAndTime() {
    return startDateAndTime;
  }


  public void setStartDateAndTime(String startDateAndTime) {
    this.startDateAndTime = startDateAndTime;
  }


  public MeasurementResult endDateAndTime(String endDateAndTime) {
    
    this.endDateAndTime = endDateAndTime;
    return this;
  }

   /**
   * The local date and time the measurement ended in format MM-DD-YYYY HH:MM:SS
   * @return endDateAndTime
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "05-05-2021 22:07:55", value = "The local date and time the measurement ended in format MM-DD-YYYY HH:MM:SS")

  public String getEndDateAndTime() {
    return endDateAndTime;
  }


  public void setEndDateAndTime(String endDateAndTime) {
    this.endDateAndTime = endDateAndTime;
  }


  public MeasurementResult durationSec(BigDecimal durationSec) {
    
    this.durationSec = durationSec;
    return this;
  }

   /**
   * The number of seconds the measurement took from start to end
   * minimum: 0
   * maximum: 9999
   * @return durationSec
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The number of seconds the measurement took from start to end")

  public BigDecimal getDurationSec() {
    return durationSec;
  }


  public void setDurationSec(BigDecimal durationSec) {
    this.durationSec = durationSec;
  }


  public MeasurementResult result(ResultEnum result) {
    
    this.result = result;
    return this;
  }

   /**
   * The overall result of the measurement
   * @return result
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The overall result of the measurement")

  public ResultEnum getResult() {
    return result;
  }


  public void setResult(ResultEnum result) {
    this.result = result;
  }


  public MeasurementResult testResults(Object testResults) {
    
    this.testResults = testResults;
    return this;
  }

   /**
   * The test results.  Will need to flush this out as we go on as to what this looks like
   * @return testResults
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The test results.  Will need to flush this out as we go on as to what this looks like")

  public Object getTestResults() {
    return testResults;
  }


  public void setTestResults(Object testResults) {
    this.testResults = testResults;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MeasurementResult measurementResult = (MeasurementResult) o;
    return Objects.equals(this.consumableName, measurementResult.consumableName) &&
        Objects.equals(this.startDateAndTime, measurementResult.startDateAndTime) &&
        Objects.equals(this.endDateAndTime, measurementResult.endDateAndTime) &&
        Objects.equals(this.durationSec, measurementResult.durationSec) &&
        Objects.equals(this.result, measurementResult.result) &&
        Objects.equals(this.testResults, measurementResult.testResults);
  }

  @Override
  public int hashCode() {
    return Objects.hash(consumableName, startDateAndTime, endDateAndTime, durationSec, result, testResults);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MeasurementResult {\n");
    sb.append("    consumableName: ").append(toIndentedString(consumableName)).append("\n");
    sb.append("    startDateAndTime: ").append(toIndentedString(startDateAndTime)).append("\n");
    sb.append("    endDateAndTime: ").append(toIndentedString(endDateAndTime)).append("\n");
    sb.append("    durationSec: ").append(toIndentedString(durationSec)).append("\n");
    sb.append("    result: ").append(toIndentedString(result)).append("\n");
    sb.append("    testResults: ").append(toIndentedString(testResults)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

