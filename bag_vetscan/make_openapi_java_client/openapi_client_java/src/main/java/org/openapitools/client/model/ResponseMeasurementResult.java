/*
 * Analyzer and HUB API
 * The definition of the software interface between analyzers and the HUB.  The interface will be implemented as a RESTful interface with all server endpoints hosted on the Analyzer.  The following requirements will be met by all interfaces:  1. All data passed back from server shall be in JSON format. 2. All query parameters and JSON data properties shall be named using snake case and be all lower case. 4. All data types that describe a measurement value shall end with an underscore followed by the unit of that physical value.  i.e. motor_current_ma.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.math.BigDecimal;
import org.threeten.bp.OffsetDateTime;

/**
 * This object will contain results of the most recent measurement
 */
@ApiModel(description = "This object will contain results of the most recent measurement")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2021-10-07T10:16:52.817798-04:00[America/Nassau]")
public class ResponseMeasurementResult {
  public static final String SERIALIZED_NAME_CONSUMABLE_NAME = "consumable_name";
  @SerializedName(SERIALIZED_NAME_CONSUMABLE_NAME)
  private String consumableName;

  public static final String SERIALIZED_NAME_START_DATETIME = "start_datetime";
  @SerializedName(SERIALIZED_NAME_START_DATETIME)
  private OffsetDateTime startDatetime;

  public static final String SERIALIZED_NAME_END_DATETIME = "end_datetime";
  @SerializedName(SERIALIZED_NAME_END_DATETIME)
  private OffsetDateTime endDatetime;

  public static final String SERIALIZED_NAME_DURATION_SEC = "duration_sec";
  @SerializedName(SERIALIZED_NAME_DURATION_SEC)
  private BigDecimal durationSec;

  /**
   * The overall result of the measurement
   */
  @JsonAdapter(ResultEnum.Adapter.class)
  public enum ResultEnum {
    FAILED("Failed"),
    
    CANCELLED("Cancelled"),
    
    COMPLETED("Completed");

    private String value;

    ResultEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ResultEnum fromValue(String value) {
      for (ResultEnum b : ResultEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ResultEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ResultEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ResultEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ResultEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_RESULT = "result";
  @SerializedName(SERIALIZED_NAME_RESULT)
  private ResultEnum result;

  public static final String SERIALIZED_NAME_TEST_RESULTS = "test_results";
  @SerializedName(SERIALIZED_NAME_TEST_RESULTS)
  private Object testResults;


  public ResponseMeasurementResult consumableName(String consumableName) {
    
    this.consumableName = consumableName;
    return this;
  }

   /**
   * A descriptive name of the consumable that can be used to uniquely identify it
   * @return consumableName
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A descriptive name of the consumable that can be used to uniquely identify it")

  public String getConsumableName() {
    return consumableName;
  }


  public void setConsumableName(String consumableName) {
    this.consumableName = consumableName;
  }


  public ResponseMeasurementResult startDatetime(OffsetDateTime startDatetime) {
    
    this.startDatetime = startDatetime;
    return this;
  }

   /**
   * The date and time the measurement was started in date-time format
   * @return startDatetime
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "2020-11-05T13:15:30Z", value = "The date and time the measurement was started in date-time format")

  public OffsetDateTime getStartDatetime() {
    return startDatetime;
  }


  public void setStartDatetime(OffsetDateTime startDatetime) {
    this.startDatetime = startDatetime;
  }


  public ResponseMeasurementResult endDatetime(OffsetDateTime endDatetime) {
    
    this.endDatetime = endDatetime;
    return this;
  }

   /**
   * The date and time the measurement ended in date-time format
   * @return endDatetime
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "2020-12-02T14:29:27Z", value = "The date and time the measurement ended in date-time format")

  public OffsetDateTime getEndDatetime() {
    return endDatetime;
  }


  public void setEndDatetime(OffsetDateTime endDatetime) {
    this.endDatetime = endDatetime;
  }


  public ResponseMeasurementResult durationSec(BigDecimal durationSec) {
    
    this.durationSec = durationSec;
    return this;
  }

   /**
   * The number of seconds the measurement took from start to end
   * minimum: 0
   * maximum: 9999
   * @return durationSec
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The number of seconds the measurement took from start to end")

  public BigDecimal getDurationSec() {
    return durationSec;
  }


  public void setDurationSec(BigDecimal durationSec) {
    this.durationSec = durationSec;
  }


  public ResponseMeasurementResult result(ResultEnum result) {
    
    this.result = result;
    return this;
  }

   /**
   * The overall result of the measurement
   * @return result
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The overall result of the measurement")

  public ResultEnum getResult() {
    return result;
  }


  public void setResult(ResultEnum result) {
    this.result = result;
  }


  public ResponseMeasurementResult testResults(Object testResults) {
    
    this.testResults = testResults;
    return this;
  }

   /**
   * The test results.  Will need to flush this out as we go on as to what this looks like
   * @return testResults
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The test results.  Will need to flush this out as we go on as to what this looks like")

  public Object getTestResults() {
    return testResults;
  }


  public void setTestResults(Object testResults) {
    this.testResults = testResults;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ResponseMeasurementResult responseMeasurementResult = (ResponseMeasurementResult) o;
    return Objects.equals(this.consumableName, responseMeasurementResult.consumableName) &&
        Objects.equals(this.startDatetime, responseMeasurementResult.startDatetime) &&
        Objects.equals(this.endDatetime, responseMeasurementResult.endDatetime) &&
        Objects.equals(this.durationSec, responseMeasurementResult.durationSec) &&
        Objects.equals(this.result, responseMeasurementResult.result) &&
        Objects.equals(this.testResults, responseMeasurementResult.testResults);
  }

  @Override
  public int hashCode() {
    return Objects.hash(consumableName, startDatetime, endDatetime, durationSec, result, testResults);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ResponseMeasurementResult {\n");
    sb.append("    consumableName: ").append(toIndentedString(consumableName)).append("\n");
    sb.append("    startDatetime: ").append(toIndentedString(startDatetime)).append("\n");
    sb.append("    endDatetime: ").append(toIndentedString(endDatetime)).append("\n");
    sb.append("    durationSec: ").append(toIndentedString(durationSec)).append("\n");
    sb.append("    result: ").append(toIndentedString(result)).append("\n");
    sb.append("    testResults: ").append(toIndentedString(testResults)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

